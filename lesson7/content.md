# Занятие 7. Конструкторы классов, обработчики событий

Запустим среду разработки Eclipse и создадим новый проект для занятия

На этом занятии:
- мы выясним, где хранятся файлы нашей программы на жестком диске;
- познакомимся с понятием конструктор класса и выясним, как его использовать при создании приложений;
- познакомимся с конструкцией "try-catch" и выясним, где ее использовать при создании приложений;
- узнаем, что такое обработчик события, и выясним, как его использовать при создании приложений.


Как и на предыдущих занятиях, создадим проект ага, назовём его lesson7. Появляется папка с проектом.

Добавим к проекту два класса, для возможности разработки сразу двух программ. Первый класс назовём Main1. Поставим галочку public static void main, нажмём кнопку Готово, появляется первый класс. Создадим ещё один класс. Назовём его Main2, поставим галочку public static void main, нажмем Готово. Появился второй класс.
Для возможности переключения между программами используем закладки, находящиеся сверху. B Main1 вставим программный код, созданный на прошлом занятии, удалив блок начальной заготовки и изменяем имя класса на Main1.

### Важно!
Название основного класса - оно всегда должно совпадать с именем файла, хранящим программный код. Если имя не совпадает, программу запустить невозможно.

Вспомните, мы работали с изображением, находящимся в корневой директории диска С. Откроем диск С, здесь должен быть размещён используемый на прошлом занятии файл с названием m.gif (или с любым другим названием). Именно этот файл мы выводим в окно. Запустим проект на исполнение. Мы видим изображение, движущееся по экрану, которым можно управлять стрелочками клавиатуры.

А где можно посмотреть результаты, полученные при создании программ? Выделим курсором проект lesson7. Далее, нажав правую кнопку мыши, заходим в самую нижнюю строчку Свойства. Откроется окошко Свойства для lesson7. Это свойства проекта. В строке с названием Расположение указан путь к папке, содержащей проект. Свернём среду разработки Eclipse и попробуем перейти в эту папку в данном случае: c:/m.jpg. Папка с нашим проектом находится в папке workspace. Наименование папки с проектом совпадает с именем проекта. Если зайти внутрь этой папки, можно обнаружить две вложенные папь bin и srс, которые в данном случае нас интересуют.

В папке src находятся файлы, содержащие код создаваемых нами программ. В данном случае, было создано 2 программы, поэтому здесь находятся 2 файла: Main1.java и Main2.java. Если при помощи приложения Блокнот открыть первый файл, можно увидеть программный код, отображенный в данный момент в нашей среде разработки. То есть программный код хранится в файле с расширением .java. Все файлы с программным кодом, написанные на языке Java, хранятся в файлах с расширением .java в текстовом виде. 

### Важно!
Название файла должно совпадать с названием основного класса
программы, - класса, содержащего метод.

Kласс public static void main(StringlI args) - это основной класс.

### Важно!
Регистр букв имеет значение! Если назвать программу, например, prog маленькими буквами, такими же маленькими буквами нужно тогда назвать и основной класс, иначе программа не запустится.

Поднимемся на уровень выше. Вторая папка, bin, содержит результаты нашей деятельности. На языке Java программы компилируются в так называемый, промежуточный программный byte-code. При запуске программы, byte-code, при помощи виртуальной машины Java, компилируется в окончательный код, который запускается под конкретную операционную систему (в данном случае, это Windows). Такая схема нужна, чтобы программа, написанная на языке Java, могла выполняться при использовании разных операционных систем. Файлы с промежуточным byte-собе имеют расширение .class.
Промежуточный byte-соdе виртуальная машина Java запускает на исполнение после его преобразования под конкретную ОС.

### Важно!
Программы Java не запускаются без установленной виртуальной машины Java. В нашем случае эта машина уже установлена в самом начале, при установке пакета разработчика (JDK). Если на компьютере пользователя этой машины нет, программа не запустится, то есть, сначала нужно установить виртуальную машину Java.

Если файл, написанный в byte-code, открыть, например, при помощи приложения Блокнот, вместо текста с программным кодом, мы увидим малопонятный код, не очень удобный для чтения. Это и есть промежуточный byte-code Java, преобразуемый виртуальной машиной в исполняемый код. После окончания разработки нашей первой игры, мы все эти файлы промежуточного byte-соdе совместим, воссоединим вместе в одно целое, которое и будет запускаться. 

Таким образом, написанные нами программы сохраняются в файлах с расширением java, находящихся в папке src. После запуска программы, когда она запускается на исполнение, компилируется промежуточный byte-соdе, который будет храниться в папке bin.

Вернемся к нашему новому проекту.

Оставим пока программный код, написанный нами ранее, без изменений и
переключимся на вторую закладку Main2.

Ниже находятся комментарии, созданные автоматически при добавлений нового класса к проекту. Удалим их - комментарии на работу программы не влияют. У нас получится следующее:

```

public class Main2 {
    public static void main(String[] args) {

    }
}

```

Мы продолжаем изучать обьектно-ориентированный язык программирования Java и рассмотрим сейчас такое понятие, которое называется конструктор класса.

Для этого в самом низу, под основным классом, под последней фигурной скобкой, создадим класс под названием MyClass. Для этого запишем строку:
```
class MyClass {
    
}
```

### Вспомним!
Класс может содержать внутри себя как переменные (или свойства), так и методы. Методы всегда ассоциируются с каким-то действием, что-то выполняют. Выполняют они то, что указано в фигурных скобках, относящихся к данному методу.


Добавим метод с названием show (показать), запишем строку:

```
public void show() 
```

### Вспомним!
Слово public говорит о том, что метод является открытым, т. е. его можно будет вызвать вне класса.

В фигурных скобках метода show (открывающей и закрывающей) запишем команды, которые будут выполняться при вызове этого метода. Добавим команду:
```
System.out.println("Это работает метод класса!");
```

При вызове метода show сработает команда, записанная в фигурных скобках.

Здесь может быть любое необходимое количество команд. В методе main создадим объект: укажем его тип. Тип совпадает с именем класса, то есть MyClass, назовём его, например, obj:

```
MyClass obj = new MyClass();
```

Мы создали переменную типа MyClass с названием obj. (После создания класса у нас появился новый тип с наименованием MyClass). В правой части этой строки на основании класса MyClass создан новый обьект: new MyClass().

Теперь через имя переменной можно обращаться к этому объекту и через оператор точка ".", вызывать методы, которые есть у данного класса. В данном случае, вызываем:

```
obj.show();
```

Получился следующий программный код:

```

public class Main2 {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.show();
    }
}

class MyClass {
    show() {
        System.out.println("Это работает метод класса!");
    }
}

```

После создания метода show(), этот метод появился в списке окна, выпадающего при указании оператора точка ".", то есть этоот метод известен системе, и мы можем им воспользоваться, вызвав его оператором точка ".".

// image !!!

Попробуем запустить программу. Команда System.out.println("Это работает метод класса!"); выводит сообщение в консольное окно. Она сработала потому, что из списка методов был выбран метод класса show(), и произошло обращение именно к этой команде, так как она находится в фигурных скобках описания выбранного метода show().

Конструктор класса отличается от обычного метода тем, что вызывается автоматически уже на стадии создания объекта на основании этого класса. Конструктор - это тоже метод, но особенный.

Создадим конструктор класса.

### Важно!
Существует правило для создания конструктора:
    В отличие от обычного метода класса, имя конструктора класса всегда совпадает с именем самого класса, и конструктор является открытым (public).

Внутри нашего конструктора добавим строку.

```
System.out printin("Это работает конструктор класса!");
```

Удалим строку вызова метода show() - obj.show();, оставив только строчку создания объекта. Получится следующий программный код:

```

public class Main2 {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
    }
}

class MyClass {
    public MyClass() {
        System.out.println("Это работает конструктор класса!");
    }

    public void show() {
        System.out.println("Это работает метод класса!");
    }
}

```

Запустим заново программу и видим в консольном окне надпись: "Это работает конструктор класса!". При создании объекта, сразу произошло обращение к конструктору (методу, имеющему название, совпадающее с названием класса). Конструктор нужен для возможности производить начальную настройку объекта, задавать начальные инициализирующие действия, происходящие при создании объекта. В отличие от обычного метода, он всегда срабатывает при создании объекта. Конструктор класса вызывается в правой части строки MyClass obj = new MyClass();.

В левой части указан тип создаваемого объекта - тип переменной obj.

Теперь, если снова вызвать и метод show():

```
obj.show();
```

после запуска программы появятся обе строки в консольном окне:

// image !!!!

Конструктор был вызван сразу при создании объекта; метод - при обращении к нему. Конструктор класса можно и не использовать, то есть никаких начальных настроек не производить. Переключимся на нашу программу, написанную ранее: зайдём в закладку Main1. Рассмотрим класс Frame:

```
class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container cont = getContentPane();
		cont.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true);
	}
}
```

Класс Frame - класс окна, он наследуется от класса JFrame, то есть, от класса всех окон. А внутри класса Frame находится конструктор класса Frame. Об этом свидетельствует его название, в точности совпадающее с именем класса: public Frame(). Это и есть конструктор класса Frame. В данном случае, этот метод, то есть конструктор, производит инициализирующие, настроечные действия с нашим окном. Именно здесь мы устанавливаем такие вещи, как размер окна и его расположение - SetBounds; заголовок окна - setTitle. Также мы создаем панель и размещаем её внутри окна, при помощи строк:

```
        Panel pn = new Panel(); // создается панель - объект
		Container cont = getContentPane(); // создаем переменную для связывания окна и панели
		cont.add(pn); // добавляем панель в окно
```

И, наконец, последняя строчка, setVisible, - делает окно видимым. Часть кода, конструктор класса, срабатывает именно в момент создания обьекта с названием f.

```
Frame f = new Frame();
```

Этой строки достаточно для того, чтобы появилось настроенное определенным образом окно. Перейдем ниже, в следующий класс, под названием Panel: класс, создающий панель. Он наследуется от класса панелей JPanel, то есть, после операции наследования, класс Panel обретает все свойства, все возможности любой панели, вкладывающейся в окно.
Строка:

```
    Panel pn = new Panel();
```

создает панель, которая потом будет вкладываться в окно. Класс, находящийся ниже, описывает то, что происходит внутри этой панели. Внутри этой панели мы производим анимацию, то есть передвижение графического объекта. И точно так же, у класса Panel есть тоже свой конструктор с названием Panel:

```	
	public Panel() {
		
		addKeyListener(new Key());
		setFocusable(true);
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (direction == 0) x--;
				if (direction == 1) y--;
				if (direction == 2) x++;
				if (direction == 3) y++;
				repaint();
			}
		});
		nt.start();
		try {
			img = ImageIO.read(new File("c:\\m.gif"));
		} catch (IOException exp) {}
	}
```

В данном случае, этот конструктор производит начальные настроечные действия, связанные с панелью.

Итак, в двух классах, использованных нами ранее, мы имеем два конструктора внутри каждого класса.

А сейчас рассмотрим конструкцию под названием try-catch (в переводе, попытка-исключение). Перейдем на закладку Main2, удалим созданный внизу класс и создание объекта с вызовом метода класса.

Напишем следующий код:

```
public class Main2 {
    public static void main(String[] args) {
        int val = 10;

        try {
            val = val / 0;
        } catch(Exception ex) {
            System.out.println("Произошла ошибка!");
        }
        System.out.println(val);
    }
}
```

Рассмотрим, как работает эта конструкция и для чего она нужна.

Мы создали переменную целого типа под названием val и присвоили ей значение 10.

После этого была записана конструкция try-catch. Такую конструкцию мы уже использовали при создании графического объекта в программе, которую мы скопировали в файл Main1.java.

Она служит для обработки исключительных ситуаций. Часть try является попыткой, часть catch - исключением. Строки, находящиеся в фигурных скобках программного кода блока try, выполняются. Если они выполняются успешно, программа обходит блок catch и выполняет действия, указанные ниже этого блока. Если же происходит какая-то ошибка, то есть, исключительная ситуация, запускаются строки, находящиеся в фигурных скобках программного кода блока catch. В данном примере, ошибкой является деление на 0, поэтому запускается блок catch. В результате выполнения команд этого блока на экран должно выводиться сообщение, что произошла ошибка. Запустим программу на исполнение и убедимся в этом - появилась надпись: "Произошла ошибка!". Значит, в блоке try произошла исключительная, ошибочная ситуация. Если же ошибки не происходит, блок catch не срабатывает, и строки кода, находящиеся в нём, не выполняются: поменяем 0 на 10. Теперь операция является правильной, делить на 10 можно.

```
public class Main2 {
    public static void main(String[] args) {
        int val = 10;

        try {
            val = val / 10;
        } catch(Exception ex) {
            System.out.println("Произошла ошибка!");
        }
        System.out.println(val);
    }
}
```

Запустим нашу программу заново. Теперь уже нет сообщения об ошибке, сработали строки программного кода try, и число, присвоенное переменной val в результате деления на 10, вывелось на экран.

Когда используется блок try-catch? Если при выполнении какой-либо части программы есть вероятность ошибки, эту часть программы можно поместить в блок try. Тогда, в случае ошибки, блок catch поможет её обойти.

Для этого в фигурные скобки блока catch помещают описание необходимых для корректировки действий. Внутри круглых скобок catch указана переменная типа Exception, в переводе - исключительная ситуация.
Вернёмся к нашей программе Main1. В нашей программе блок try-catch находится внутри конструктора класса, отвечающего за формирование панели, внутри которой производится передвижение объекта.

```

try {
    img = ImageIO.read(new File("c:\\m.gif"));
} catch(IOException exp) {}

```

Здесь конструкция try-catch представляет из себя всего одну команду внутри блока try, именно в этой строке происходит загрузка изображения из корневой папки диска С в переменную img. Она объявлена как переменная внутри класса, у неё тип Image - картинка. Переменная закрытая - private, значит, переменная доступна только внутри нашего класса, то есть за пределами класса через оператор точка "." к ней обратиться уже нельзя. Конструкция try-catch здесь используется потому, что операция чтения файла с диска, или загрузка изображения, может произойти неуспешно, с ошибкой. Файл с изображением может быть удалён, перенесён в другое место (на другой диск) или переименован. Соответственно, загрузка будет неуспешной, и сработает часть catch. В данном случае, внутри фигурных скобок блока сatch нет никакого программного кода, значит исключительная ситуация не обрабатывается. Если картинка не загрузится, мы ничего не увидим на экране, и программа просто будет выполняться дальше, ниже блока catch. При запуске этой программы мы видим подвижный обьект, его движением можно управлять при помощи стрелок с клавиатуры. Попробуем изменить логику нашей программы, подкорректируем её действия так, чтобы увидеть другую картину при запуске приложения. Перейдём в самую нижнюю часть программы. Внутри класса Panel находится метод paintComponent, отвечающий за рисование на панели. Внутри этого метода содержится один параметр типа Graphics с наименованием gr. Именно через этот параметр вызываются методы, производящие рисование на нашей панели. Здесь находятся две команды. Первая - gr.clearRect, очищающая область экрана. Эта команда удаляет предыдущее положение графического объекта. Таким образом, при движении объект не оставляет след. Закоментируем эту строчку:

```
// gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
```

Теперь строчка выполняться не будет. Заново запустим программу. Тот же самый графический объект, но теперь он после своего движения оставляет след на экране. Это происходит, т.к. мы отключили метод gr.clearRect, и он в прежнем положении объекта не производит очищение этой области. Немного изменим команду gr.drawlmage. Эта команда рисует изображение, выводит его на экран. Первый параметр - имя изображения, загружаемого с диска в переменную іmg. Далее, х и у, координаты его угловой точки, то есть верхней левой точки этого объекта. х и у заданы постоянно меняющимися, значит, объект каждый раз выводится в другом месте. Последний параметр указан, как null, то есть параметр не используется. В методе gr.drawImage можно добавить еще два параметра, например, вот так:

```
gr.drawImage(img, x, y, 100, 100, null);
```

Все параметры, помещенные в скобки метода, разделяются запятыми. Новые, указанные здесь параметры, отвечают за ширину (первый) и высоту (второй) графического объекта. Запустим снова наше приложение и посмотрим, что изменилось. Изображение уменьшилось, т.к. область, внутри которой размещается графический объект, теперь составляет 100 на 100 пикселей. Эти размеры меньше исходных, и изображение стало меньше. Зададим эти размеры, например, по 10 и посмотрим, как изменится размер изображения. Картинка стала совсем маленькой. Мы не очищаем при помощи метода gr.clearRect предыдущее положение объекта, и он оставляет след. Если теперь значения ширины и высоты обозначить, соответственно, переменными х и у, ширина и высота нашего графического объекта также будет постоянно меняться так же, как меняется его позиция. На каждом шаге переменным x и у будут присваиваться разные значения. Запустим программу.

```
gr.drawImage(img, x, y, x, y, null);
```

Объект постоянно меняется по ширине и по высоте при перемещении в разные области экрана, так как значения ширины и высоты объекта постоянно меняются в программе. Меняются, соответственно, размеры объекта. Метод gr.clearRect отключён, поэтому объект оставляет след. Удалим комментарии у метода gr.clearRect:

```
gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
```

Первые два параметра метода gr.clearRect указывают на точку, удалённую от верхнего левого угла - точку начала прямоугольной области, которая будет очищаться. Далее: ширина и высота этой прямоугольной области. Это размер, на единицу больший размера объекта, перед тем, как он переместился в новую точку. Запустим заново наше приложение.

Теперь объект не оставляет след на экране, так как метод gr.clearRect постоянно стирает его отображение, бывшее на предыдущем шаге. Теперь наша картинка летает без следа.

Теперь рассмотрим понятие "обработчики события".

При работе с окном, выведенным на экран компьютера, пользователь осуществляет, инициирует какие-то события, например, событие изменения положения курсора мыши или нажатия клавиш на клавиатуре. Операционная система, в свою очередь, отправляет окну сообщения, связанные с этими событиями. Именно эти сообщения мы можем обрабатывать внутри программы.

Например, пользователь осуществляет нажатие клавиш стрелки на клавиатуре. Происходит событие нажатия клавиш, и операционная система отправляет эти события в виде сообщений в программу. В программе можно эти события проанализировать и отреагировать на них. Мы в программе анализируем нажатую клавишу и меняем направление движения объекта.

События могут быть разных типов. Всё, что происходит с окном, является событием. Перемещение окна по экрану - это событие. Изменение размера окна - тоже событие и т.д. Всё, что происходит с окном, операционная система отправляет в программу в виде сообщений. Если это необходимо, можно обрабатывать эти события и реагировать на них определенными действиями.

Вернёмся к нашей программе, откроем закладку Main1 и посмотрим, с какими событиями мы уже работали.

Первое событие связано с обработкой нажатия клавиш. Для обработки события нажатие клавиши был создан класс Кеу:

```

private class Key implements KeyListener {
    public void keyPressed(KeyEvent e) {
        int key_ = e.getKeyCode();
        
        if (key_ == 37) direction = 0;
        if (key_ == 38) direction = 1;
        if (key_ == 39) direction = 2;
        if (key_ == 40) direction = 3;
    }
    public void keyReleased(KeyEvent e) {}
    public void keyTyped(KeyEvent e) {}
}

```

Рассмотрим наиболее важные моменты, связанные с этим классом.

Метод keyPressed срабатывает при нажатии клавиши на клавиатуре пользователя. Внутри метода находится параметр - KeyEvent. Тип параметра KeyEvent. Именно через этот параметр можно получить код нажатой клавиши. Для того, чтобы получить код нажатой клавиши, необходимо вызвать метод e.getKeyCode(); и получить код нажатой клавиши, используя параметр е. Каждая клавиша при нажатии имеет свой код, представляющий из себя число, и каждая клавиша, соответственно, возвращает разный код.

Под строкой int key_ = e.getkeyCode(); добавим строку: System.out.println(key_); - команду, которая выводит сообщение в консольное окно, и поместим в круглые скобки переменную с названием кеу_ целого типа.

```
    int key_ = e.getKeyCode();
    System.out.printin(key_);
```

В переменную key_ метод e.getKeyCode(); вернёт код нажатой клавиши. Например, если вы нажмете клавишу Escape, метод .getKeyCode(); вернет число 27. Это число 27 будет присвоено переменной key_. В следующей строке описывается вывод переменной кеу на экран. При запуске программы, нажимая разные клавиши, мы сможем видеть их код, то есть код нажатой клавиши в консольном окне.

Запустим программу. При нажатии на клавишу Escape, отображается код 27. При нажатий на клавишу Пробел, появляется код 32. При нажатии на клавишу стрелка вверх - код 38. Именно этот код и прописан в нашей программе, т. е. 38 - это нажатие клавиши стрелка вверх. При нажатии на клавишу стрелка вниз, видим код 40, При нажатии на клавишу влево - 37, При нажатии на клавишу вправо - 39.

Таким образом, 37, 38, 39, 40 - числовые коды, которые отвечают за клавиши стрелки, то есть при нажатии какой-либо клавиши стрелка, е.getKeyCode( ); возвращает, соответственно, эти числа. Таким образом, можно посмотреть, какой код соответствует нужной вам клавише. В программе можно его проанализировать при помощи конструкции if.
Внутри конструкции іf всегда стоят круглые скобки. В них указывается условие, в данном случае, условие сравнения. Сравнение отображается при помощи двух знаков "равно" идущих подряд (==):

```
if (key_ == 37) direction = 0;
if (key_ == 38) direction = 1;
if (key_ == 39) direction = 2;
if (key_ == 40) direction = 3;
```

Рассмотрим строку: if (key_ == 37) direction = 0;. Переменная direction отвечает за направление движения. Это переменная целого типа. И, соответственно, 4 направления - это 0, 1, 2, 3. Именно по этой переменной далее в программе определяется, в каком направлении должен двигаться объект. И, соответственно, при нажатии клавиши, переменная direction меняет свое значение, и объект будет двигаться уже в другом направлении.

Для начала обработки события "нажатие клавиши" , необходимо подключать
конструкцию, созданную нами ранее внутри конструктора класса Panel.

```
public Panel() {
		
		addKeyListener(new Key());
		setFocusable(true);
```

Эти две строки отвечают за подключение обработчика события к нашей панели. На основании класса под названием Key, создается объект типа new Key() и вызывается метод addKeyListener. Этот метод подключает обработчик события к нашей панели. Таким образом, панель может обрабатывать события при нажатии клавиши.

Затем идёт метод setFocusable(true);, отвечающий за то, чтобы панель стала в фокусе, то есть стала активной.

Второй обработчик событий, с которым мы уже работали, - "таймер".

```

Timer nt = new Timer(50, new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        if (direction == 0) x--;
        if (direction == 1) y--;
        if (direction == 2) x++;
        if (direction == 3) y++;
        repaint();
    }
});
nt.start();

```

Эта часть программы отвечает за формирование, обработку, подключение таймера к нашей панели. Таймер - инструмент, позволяющий создавать события через заданный интервал времени. Таймер срабатывает периодически, через определённое время. Данная конструкция используется для обработки события по таймеру, т. е. через заданный промежуток времени.

Создается переменная типа Timer, имя может быть любым, в нашем случае, nt. Далее создается новый объект new Timer(). Внутри фигурных скобок происходит обработка события по таймеру. Команда nt.start(), запускает таймер после того, как он создан. Если эту команду не выполнить,таймер работать не будет. Внутри метода public void actionPerforme (ActionEvent e) происходит обработка события. Интервал срабатывания таймера в нашем случае указан 0,025 с.. Это означает, что через каждые 25 тысячных секунды будет происходить обработка события по таймеру внутри метода public void actionPerformed(ActionEvent e). Будут выполняться следующие строки:

```

if (direction == 0) x--;
if (direction == 1) y--;
if (direction == 2) x++;
if (direction == 3) y++;
repaint();

```

В этих строках мы меняем значения координат обьекта по осям х и у. Если переменная direction = 0, то x уменьшается на единицу. Если переменная direction = 1, то переменная у уменьшается на единицу и т. д. В зависимости от того, в каком направлении должен двигаться объект, мы меняем координату его верхней левой точки. Так как мы постоянно меняем значения координат, ширины и высоты объекта, метод gr.drawImage(img, x, y, x, y, null); будет выводить объект в разном месте и с разными размерами. И, наконец, после изменения координат нашего объекта, вызываем метод repaint();. Метод repaint(); отвечает за перерисовку панели. При вызове метода repaint();, срабатывает метод public void paintComponent(Graphics gr), и происходит выполнение двух команд, которые очищают область и вводят объект в новом месте. При срабатывании таймера постоянно происходит выполнение этих строк. В зависимости от значения переменной direction, изменяется значение переменных х и у.

В самом верху класса Panel объявлены переменные класса, его свойства:

```
class Panel extends JPanel {
	private int x = 0, y = 0;
	private Image img;
	private int direction = 2; 
    
    ...
}
```

В данном случае, мы описали свойства, относящиеся к нашей задаче по созданию анимации изображения.

Одно из них - img, - картинка, выводимая на экран, второе - direction - направление движения, изначально ему присваивается значение 2. И еще два дополнительных свойства - х и у - значение верхней левой точки объекта. Таким образом, программа представляет следующую схему:

- создаётся класс под названием Panel;
- внутри класса описывается, как отображается наша панель и что с ней происходит во время выполнения программы.
- затем, на основании этого класса, в строке программного кода Panel pn = new Panel(); создается обьект под названием pn - реальная панель, которую мы вкладываем в окно (внутри класса Frame, так как класс Frame отвечает за окно),
- внутри класса Frame устанавливаются начальные настройки окна: его размеры, место расположения и название;
- внутри основного, главного класса (он называется так же, как и файл, содержащий программный код: Main1), находится метод public static void main(String[] args), который запускает программу на исполнение. Он и создает окно, и в этот момент мы видим перемещение графического объекта на экране (точка входа в программу).

Всё находящееся ниже в виде двух классов, - описание логики, заложенной внутри окна и внутри панели, вкладываемой в окно.

Рассмотрим, как можно менять значения переменных.

```

if (direction == 0) x--;
if (direction == 1) y--;
if (direction == 2) x++;
if (direction == 3) y++;

```

Допустим, есть переменная і целого типа. В данный момент, переменная і равна десяти: т. е., существует область, ячейка оперативной памяти, содержащая значение 10. Эта ячейка cвязана с переменной под названием і. Значит, обращаясь к переменной і, мы обращаемся к ячейке,  содержащей значение 10. Запишем следующую строку: і=і+1. Как всегда, сначала работает правая часть: і+1. К значению : і, т. е., к десяти прибавляется единица и получается новое значение 11. На втором шаге новое значение, 11, помещается в ячейку, ранее содержащую 10. Значение 10 уничтожается.

Теперь значение переменной і становится равным 11: происходит увеличение на единицу. Эту операцию можно записать таким образом: і++. Это более удобный способ, поэтому в большинстве случаев именно его и используют. Мы тоже использовали его, когда увеличивали значение х и у на единицу. Методы і=і+1 и і++ абсолютно равноценны. Можно использовать и тот, и другой. Так же можно и уменьшать значение переменной, например на 1: i=i-1 и і--. А если нужно изменить значение переменной, например, на 5, можно записать такую конструкцию: і = i+5. Значение переменной увеличивается на 5. В результате в ячейку і помещается новое значение - 15. Эту конструкцию можно записать более удобным способом: і+=5 как обычно и делают. Эта запись означает, что к і будет прибавлено значение 5. Записи і=і+5 и і+=5 абсолютно равноценны. Можно использовать любую из них. Обычно используется второй вариант записи - он короче. Если вместо знака + поставить знак -, і уменьшится на 5. Можно увеличивать и уменьшать переменную на любое значение, если это понадобится.

Воспользуемся новой формой записи и зададим в программе пошаговое изменение переменных х и у не на 1, а на 2.

```
if (direction == 0) x-=2;
if (direction == 1) y-=2;
if (direction == 2) x+=2;
if (direction == 3) y+=2;
```

Запустим программу.

Каждый шаг, на который теперь передвигается графический объект, стал в два раза больше, поэтому обьект перемещается в два раза быстрее. При пошаговом изменении переменных х и у на 3, объект перемещается ещё быстрее. Таким образом, с увеличением шага, он будет перемещаться все быстрее и быстрее. Кроме того, объект начинает оставлять след, т. к. параметры очищения области остались неизменными: при очищении области всегда брался прямоугольник, превышающий размер самого объекта всего на один пиксель.

Этого хватало, чтобы захватить область нахождения объекта на предыдущем шаге. На данном этапе, правильнее будет поменять значения параметров очищения области. Заменим 1 на 2 и посмотрим, как двигается объект.

```
gr.clearRect(x-2, y-2, img.getWidth(null)+2, img.getHeight(null)+2);
```

Таким образом, внося некоторые изменения в программу, можно менять её логику. Рассмотрим ещё один пример.

Теперь поменяем траекторию движения объекта. Пусть наш объект при запуске программы перемещается по диагонали:

```
if (direction == 0) x-=2;
if (direction == 1) y-=2;
if (direction == 2) {
    x+=2;
    y+=2;
};
if (direction == 3) y+=2;
```

Мы добавили фигурные скобки. Они нужны, чтобы отметить блок, относящийся к оператору if. Теперь оператор іf включён в блок. Строки:

```
{
    x+=2;
    y+=2;
}
```

описывают одновременное изменение переменных х и у, их пошаговое увеличение на 2.

Запустим программу - теперь объект начинает двигаться по диагонали. Мы поменяли логику его движения только при нажатии одной клавиши. Значит, при нажатии на другие три клавиши ничего не изменилось: лишь при нажатии клавиши "Вправо" объект начинает двигаться по диагонали. Можно, например, при направлении, равном нулю, задать схему движения объекта, когда он будет двигаться по диагонали, но в другую сторону. Значения х и у при этом уменьшаются на единицу.

```
if (direction == 0) {
    x-=2; 
    y-=2;
}
```

Теперь при нажатии клавиш "Вправо" и "Влево" объект начинает двигаться по диагонали. Так как одновременно меняется и размер обьекта, его ширина и высота, возникает эффект приближения. Будто объект издалека приближается и затем отдаляется.

Используя эти разнообразные приёмы, можно задавать перемещение графическим объектам. Объектов может быть несколько, у каждого из них может быть заложена своя логика перемещения по различным траекториям, заданным в программе. Можно создать игру, связанную с перемещениями графических объектов, например, летающих тарелок, космических кораблей и т.п.