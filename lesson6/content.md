# Занятие 6. Работа с графическими изображениями.

### На этом занятииЖ 
- мы научимся загружать в создаваемое нами гзафическое приложение графические файлы и выводитьь их на экран
- научимся создавать анимированное движение 
- научимся управлять движущимся графическим объектом с помощью клавиатуры

## Ход занятия 

Откроем Eclipse и создадим новый проект - lesson6

Удалим заготовку программы, так как мы будем использовать начальную заготовку программы, сделанную нами на прошлом занятии. Откроем программу прошлого занятия с готовым исходным кодом, скопируем его и вставим его в наш новый проект.

\\ Main.java
``` 
    import java.awt.*;
    import javax.swing.*;
    public class Main {
        public static void main(String[] args) {
            Frame nf = new Frame();
        }
    }
    class Frame extends JFrame {
        public Frame() {
            Panel pn = new Panel();
            Container c = getContentPane();
            c.add(pn);
            setBounds(10, 10, 800, 600);
            setVisible(true); 
        }
    }
    class Panel extends JPanel {
        public void paintComponent(Graphics gr) {
            gr.setColor(Color.BLUE);
            for (int i = 0; i < 10; i++) {
                gr.fillRect(10*i, 10*i, 50*i, 50*i);
            }
        }
    }
```


Повторим основные моменты прошлого занятия.

Команда import осуществляет добавление библиотек для возможности их использования в нашей программе. Библиотека - это набор определенных функций, вызываемых в виде команд для выполнения тех или иных задач.
	
Основной класс программы - этот класс всегда называется так же, как и имя файла, содержащего программу. В данном случае - Main. Внутри этого класса находится метод, который создается при установке галочки для создания классов public static void main(String[] args). Метод main -  метод, который запускает программу. 

Frame f = new Frame(); - строка, которая создает объект окна на основании класса, который описан ниже (class Frame extends JFrame). Внутри этого класса описывается настройка, связанная с окном. Слово class говорит о том, что создан классс под названием Frame. Название класса может быть произвольным, как и название переменной. Оператор extends присваивает классу Frame наследование свойств класса JFrame. Класс Frame содержит один метод, который производит инициализвцию окна. setBounds  - устанавливает положение окна и его размеров. Первые две характеристики - отступы, остальные две отвечают за размеры окна. Panel является типом переменной под названием pn. В части new Panel(); мы создаем объект под названием pn. Эта панель будет вставлена в наше окно. На ней будет отображаться графика. Панель представляет из себя прямоугольную область, размещенную внутри окна. Далее идет строка Container cont = getContentPane(); позволяющая подключать к окну компоненты. Эта связка происходит через переменную cont. Название может быть любым, но желательно имя переменной задавать созвучным ее назначению. Строка cont.add(pn); прикрепляет панель к нашему окну - вкладывает ее к окну. Строка setVisible(true); позволяет сделать окно видимым.

В программе описан еще один класс - класс под название Panel, он наследуется от класса JPanel. Класс JPanel - класс панелей, которые можно размещать внутрь окна.

Метод public void paintComponent используется для возможности рисования на панели или отображения внешних графических файлов с диска.

Мы продолжаем работать с графикой и сейчас мы рассмотрим работу с изображениями, находящимися в графических файлах.

Для возможности использования изображений, хранящихся в файлах на вашем компьютере, при создании приложений, их следует в программу загрузить. (изображение вы можете взять свое или же можете взять из директории текущего занятия ./img)

Любое изображение сожно поместить в прямоугольную область. Именно эта область определяет характеристики изображения. Представим, что прямоугольник внутри нашего окна - это панель, и зададим распольжение точки, относительно которой рассчитывается положение объекта. Чтобы задать положение этого изображения в нашем окне, нужно указать отступ по X и по Y (в количестве пикселей) - координаты верхнего левого угла изображения. После этого следует задать ширину и высоту изображения. Эти характеристики присутствуют у любого изображения. Выведем в окно в окно изображение, помещенное на диск C. Для этого добавим в класс Panel новую переменную. Объявим ее в самом верху класса после открывающей фигурной скобки. Используем модификатор private, тогда переменная класса будет закрытой, то есть доступной только внутри класса. Далее мы указывааем ее тип: Image, то есть картинкой: private Image img;. 

Далее создадим новый метод под названием public Panel, а код внутри метода public void paintComponent удалим, класс Panel теперь выглядит так:


```

class Panel extends JPanel {
	
	private Image img;
	
	public Panel() {
		
	}
	
	public void paintComponent(Graphics gr) {
		
	}
}

```


В метод public Panel() добавим строки:

```
try 
{
    img = ImageIO.read(new File("c://m.gif"));
} 
catch(IOException exp) {}
```

В самом верху программы добавим: 

```
import java.io.*;
import javax.imageio.*;
```

А внутри метода public void paintComponent(Graphics gr) добавим одну строку:

```
gr.drawImage(img, 10, 10, null);
```

После этого у нас получится следующая программа: 

```

import java.awt.*;
import java.io.*;
import javax.imageio.*;
import javax.swing.*;


public class Main {
	public static void main(String[] args) {
		Frame nf = new Frame();
	}
}

class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container c = getContentPane();
		c.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true); 
	}
}

class Panel extends JPanel {
	
	private Image img;
	
	public Panel() {
		try 
		{
			img = ImageIO.read(new File("c://m.gif"));
		} 
		catch(IOException exp) {}
	}
	
	public void paintComponent(Graphics gr) {
		gr.drawImage(img, 10, 10, null);
	}
}

```

В верхних 2-х строчках мы подключили две библиотеки, которые нужны для загрузки графических файлов. При помощи команды img - ImageIO.read(new File("c://m.gif")); мы загрузили в нашу программу файл под названием m.gif, который находится на диске C.

Часть строки ImageIO.read выполняет функцию чтения изображения. В первых круглый скобках создается объект типа File: new File, во внутреннних скобках указывается конкретный путь к месту нахождения изображения на диске C. То есть часть строки new File создает объект типа File и путь к этому файлу "c:\\\\m.gif". Путь указывается в двойных кавычках, как строка. Обратите внимание, что при описании пути необходимо указывать именно две косые черты. Одна косая черта является специальным символом. Чтобы дать понять компилятору, что это не специальный символ, а косая черта - их нужно писать две. Ихображение загружается и связывается в переменную img, спеуиально для этого созданной. ЕЕ тип Image - картинка. 

Метод gr.drawImage(img, 10, 10, null); - выводит этот файл на нашу панель окна. drawImage - отвечает за выведение изображения на экран. Первый параметр -  изображение img, которое мы выводим. Вторые два - координаты X и Y. Значения 10 и 10 говорят о том, что изображение выводится почти из верхнего левого угла окна. Последний параметр не указан. Неуказанные параметры отображаются, как null - специальное служебное слово, говорящее о том, что параметр пустой.

Мы обратились к переменной с именем gr типа Graphics, которая отвечает за выведение графики на нашу панель. В дальнейшем, для произведения графических манипуляций мы будем обращаться к этой переменной.

Попробуем запустить нашу программу, и если она написана без ошибок, то мы увидим изображение, выведенное на экран. Координата 10, 10 находится в левом верхнем углу окна, именно из этой точки начинается прямоугольник, содержащий изображение. Соответственно, если эту координату поменять и поставить, например, 200, 200, - после выполнения программы можно увидеть, что изображение сместилось, так как точка его начала координат переместилась. Таким образом, можно менять положение изображения на рабочей области и выводить его в любой точке. Можно использовать любые картинки, изображения, подготовленные в каком-либо графическом редакторе. К примеру, можно взять что-то готовое, и использовать в программах, например, для оформления какой-то игры, чтобы наполнить ее дизайном и графическими объектами.

Теперь перейдем к понятию анимации. Анимация движений - это перемещение графического объекта по определенной области или его изменение, в данной случае, области панели, вложенной в окно.

Можно заложить траекторию движения изображения, например, прямую линию. Вдоль этой линии будет двигаться заданный объект. Можно взять более сложную траекторию движения, например, окружность. Тогда объект будет двигаться по окружности. Для создания нашей анимации нам нужно выполнить несколько действий:

1) перемещать изображение на небольшое расстояние (пошагово). Если необходимо перемещать изображение по диагонали, его координату по X и Y нужно изменять на один пиксель, тогда оно переместиться совсем немного.
2) после перемещения очистить его предыдущее положение (еще лучше это сделать до перемещения: перед тем, как поместить изображение в новую точку).

Тогда изображение будет двигаться. В зависимости от того, на сколько пикселей за шаг пеермещается изображение, меняется плавность его движения. Есть еще одно необходимое условие - определенная временная задержка. Если ее не предусмотреть, компьютер выполнит перемещение объекта мгновенно, и объект промелькнет на экране, но заметить это будет практически невозможно. Поэтому необходимо задавать скорость движения объекта, не зависящую от скорости работы компьютера. Перед переходом на новый кадр, на новое положение изображения, делается временная задержка, допустим, какая-то доля секунды. Для этого есть специальный инструмент - таймер. 

Таймер позволяет выполнять задержку с точностью до одной тысячной секунды. Попробуем создать этот инструмент и начнем с ним работать. Добавим еще несколько полей в наш класс и назовем их x и y.
Зададим им начальное значение 0 и 0.

```

class Panel extends JPanel {
	private int x=0, y=0;

```

Это переменные x и y целого типа, они так же закрытые - private, то есть доступны только внутри класса. Они будут отвечать заположение нашего изображения на экране, то есть за положение верхней левой точки. Меняя значение параметров x и y, можно перемещать объект. Чтобы перемещение не оставляло следа и получилась реальная анимация, перед тем как отобразить изображение в новом месте, нужно очистить область от прежнего изображения. Для этой цели применяется метод clearRect - очищение прямоугольной области. Добавим над строкой вывода изображения строчку:

```

gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);

```

и в самой строке вывода поменяем значения координат 10, 10 на x и y. Получится следующий фрагмент кода:

```

public void paintComponent(Graphics gr) {
	gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
	gr.drawImage(img, x, y, null);
}

```

Обращение к методам очищения и вывода идет через переменную gr, типа Graphics. Внутри круглых скобок метода gr.clearRect, указываются: первые два парамметра - координаты верхней левой точки прямоугольной области очищения. Если перемещать объект на один пиксель, достаточно делать очищение в радиусе +- один пиксель (x-1, y-1). Получается точка, удаленная на один пиксель по x и по y, соответственно, вверх и влево. Вторые два параметра: ширина и высота прямоугольной области очищения. Обратимся к изображению img и вызовем команду getWindth(null), позволяющую вычислить ширину изображения выведенного на экран. null говорит о том, что параметр не указывается, он остается пустым. Снова обращаемся к изображению img и вызываем метод getHeight(null), она задает высоту нашего графического объекта. Именно эти два параметра указывают ширину и высоту области, которая будет очищена. К высоте и ширине прибавляем по одному пикселю, чтобы охватитьь чуть больший фрагмент, потому что объект каждый раз перемещается на один пиксель. Перед тем, как выводить изображение в новом положении панели, программа будет производить очищение области, большей на единицу со всех сторон. Так осуществляется анимация.

Теперь добавим несколько строк для работы с таймером. Их необходимо поместить в метод public Panel().

```

public Panel() {
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				x++;
				repaint();
			}
		});
		nt.start();
		
		....

```

Таким образом, мы создали таймер, он будет работать с нашим приложением. Первый параметр, который необходимо указать - его временную задержку. Мы указали 50, это значит, что задержка будет 50 тысячных секунды. При срабатывании таймера будет происходить отрисовка заданной области, то есть панели. Метод repaint(); вызывает перерисовку, вызывает на исполнение метод public void paintComponent(Graphics gr), он заново перерисовывает заданную облать. А нем у нас выполняются две команды - очищение области с положением изображения на предыдущем шаге и вывод изображения в новом месте. Перерисовка будет выполняться 20 раз в секунду - именно этому соответствует задержка 50 тысячных секунды.

Сверху подключим еще одну библиотеку:

```

import java.awt.event.*;

```

Запустим программу и увидим перемещение, анимацию нашего изображения. Полный код программы должен выглядеть так:

```

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.imageio.*;
import javax.swing.*;


public class Main {
	public static void main(String[] args) {
		Frame nf = new Frame();
	}
}

class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container c = getContentPane();
		c.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true); 
	}
}

class Panel extends JPanel {
	private int x=0, y=0;
	private Image img;
	
	public Panel() {
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				x++;
				repaint();
			}
		});
		nt.start();
		
		try 
		{
			img = ImageIO.read(new File("c://m.gif"));
		} 
		catch(IOException exp) {}
	}
	
	public void paintComponent(Graphics gr) {
		gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
		gr.drawImage(img, x, y, null);
	}
}


```


Добавим на одну строку ниже от объявления переменных x и y еще одну, переменную целого типа и назовем ее direction, присвоим ей начальное значение равное 2, переменная будет закрытой:

```

private int direction = 2;

```

Переменная direction отвечает за направление движения графического объекта. Договоримся, что у нас будет 4 возможных направления: вверх, вниз, вправо, влево. Каждое направление будет обозначаться цифрой 0, 1, 2, 3. Тогда 2 отвечает за движение вправо. Если direction = 2, объект перемещается в правом направлении. Теперь вместо строки x++;  - там, где мы создавали таймер, поместим строки:

```

if (direction == 0) x--;
if (direction == 1) y--;
if (direction == 2) x++;
if (direction == 3) y++;

```

Операция x--; означает, что значение x будет уменьшаться на единицу. Если x был равен 100, после выполнения этой операции он станет равным 99. Если direction==0, координата x уменьшится на единицу. Если direction==1, то координата y уменьшится на единицу. Если direction==2, координата x увеличится на единицу. И, наконец, если direction==3, координата y увеличится на единицу. 

Мы прописали следующее условие: если направление равно 0, координата x будет уменьшаться на единицу, и объект перемещается вл