# Занятие 10. Создание компьютерной игры "Новогодний дождь" (продолжение)


На этом занятии:
мы продолжим создавать "Новогодний дождь из подарков".
- создадим часть программного кода, отвечающую за появление подарков в случайном месте сверху на игровом поле, за движение вниз, за движение вниз до самой минимально разрешимой для подарков границы, т. е., до верхней границы шапки;
- создадим различные уровни сложности игры.


Мы приближаемся к завершению компьютерной игры. Осталось всего два занятия для того, чтобы её полностью реализовать. Игра простая, но по её примеру можно реализовать более сложную компьютерную игру с программной логикой.

Прежде всего, вспомним, в корне диска С: лежат изображения, используемые в игре. Изображений несколько: первое - изображение bg.png, оно отвечает за фон игрового поля, второе изображение - hat.png, которое отвечает за шапку Деда Мороза. Наконец, несколько изображений - подарков, их семь, и нумерация идёт с нуля: gO.png, gl.png, g2.png, g3.png, g4.png, g5.png и g6.png, - от нуля до шести ровно семь изображений. Запустим среду разработки, вспомним, на чём мы остановились в прошлый раз, что уже сделано и продолжим разработку игры. Создано 4 класса, каждый класс открывается из отдельной закладки и представляет собой отдельный файл.

Запустим программу на исполнение, посмотрим, что происходит на текущий момент.
Мы видим фон, загруженный из файла, находящегося в корне диска С:, шапку Деда Мороза, она перемещается вправо и влево при нажатии стрелочек вправо и влево. Пока больше ничего не происходит.

На прошлом занятии мы создали основной функционал компьютерной игры. Был создан класс под названием Gift. Этот класс отвечает за логику поведения изображения подарка, или, в дальнейшем, просто подарка, на игровом поле. Подарок появляется в верхней части игрового поля, в случайном месте и начинает опускаться вниз. Дальше возможны два варианта. Когда он достигает нижней границы, он либо будет пойман при помощи шапки, которая перемещается стрелочками клавиатуры, либо будет пропущен. Пропущенный подарок является окончанием игры. Если хоть один подарок пропущен, выводится сообщение конец игры и на этом игра заканчивается.

Прежде всего, откроем класс Game. И доработаем этот класс, чтобы получилось следующее, добавленный программный код выделен жирным, теперь класс Game выглядит так:

```
import javax.swing.*;

public class Game {

	public static void main(String[] args) {
		
		String answer = JOptionPane.showInputDialog(null, "Введите сложность игры от 1 до 7: ", "Сложность игры", 1);
		
		int lvl = answer.charAt(0)-'0';
		
		if ((lvl >= 1)&&(lvl <= 7)) {
			Window w = new Window(lvl);
		}
		
	}

}
```

Теперь давайте подробно разберем добавленный код. Мы создали переменную типа String и назвали eë answer. String - это переменная типа строка, в неё можно поместить любой текст: и буквы, и цифры, и специальные символы; в общем, любой текст. Текст помещается в двойные кавычки, когда указывается в программе. Далее записано, что эта переменная равна JOptionPane, после него мы вызываем оператор (.), появится список методов, которые можно использовать. Выбираем метод showInputDialog(). Это метод выводит на экран диалоговое окно. Окно предлагает ввести определённую информацию пользователю. В данном случае, оно нужно для того, чтобы пользователь при старте игры мог выбрать её сложность. В зависимости от уровня сложности, выбранного пользователем, на игровое поле будет выводиться большее или меньшее количество подарков. Значит, игра может иметь 7 уровней сложности (максимальное количество подарков - 7). Сложность игры будет указываться от 1 до 7. Если пользователь выберет уровень сложности 1, будет выводиться только один подарок. Если он выберет 7, будут выводиться сразу семь подарков, игра усложнится.

Внутри круглых скобок метода showInputDialog() введены несколько параметров.

```
String answer = JOptionPane.showInputDialog(null, "Введите сложность игры от 1 до 7: ", "Сложность игры", 1);
```

Первый параметр null, т. е., параметр не указан, можно считать, что это пустой параметр. Дальше внутри двойных кавычек написано "Введите сложность игры от 1 до 7:", - сообщение для пользователя, чтобы он указал нужную ему сложность. Следующий параметр снова в двойных кавычках, тоже текст: "Сложность игры". Это заголовок окна.

Наконец, последний параметр, 1. Единица характеризует вид диалогового окна, его можно задать также 2 или 3. Изменится информационное изображение в окне. Далее, введём переменную целого типа и назовём её lvl. Присвоим переменной значение answer.charAt(0)-'0'. У нас получится следующее: в предыдущей строке в переменную answer будет передаваться строка, которую ввел пользователь. Метод showInputDialog() присваивает значение, которое пользователь ввёл в текстовое поле, переменной answer строкового типа. В строке:

```
int lvl = answer.charAt(0)-'0';
```

мы извлекаем первый символ по номеру, нумерация в Java всегда идет с нуля, поэтому первый символ будет с номером 0. Таким образом, конструкция answer.charAt(0) вернет цифру, которую ввел пользователь в виде одного символа типа char.

Вспомним, что char, в отличие от строки, - это всегда только один символ, который указывается в одиночных кавычках.

Если из этого символа вычесть символ '0', что и сделано, то, получится целое число. Каждый символ имеет свой код от 0 до 255, а коды символов цифр идут строго по порядку, начиная с нуля. Но код символа 0 не равен нулю. Другими словами смысл такого преобразования только в одном перевести цифру введенную пользователем виде строки в тип целого числа, это как раз тип переменной lvl. Код символа '0' может быть, допустим, 150, значит, код единицы - 151. Если вычесть из 151-150, как раз получится единица. Далее записана конструкция: если - if.

```
if ((lvl >= 1)&&(lvl <= 7)) {
    Window w = new Window(lvl);
}
```

С этой конструкцией мы уже знакомы. Внутри круглых скобок конструкции if всегда находится анализируемое условие. Два символа && означают, что условия, находящиеся справа и слева от них, должны выполняться одновременно. В данном случае, условие следующее: если переменная lvl будет больше, либо равна единице и меньше, либо равна семи (если сложность больше, либо равна единице и меньше, либо равна семи), тогда условие выполняется. Мы проверяем, что пользователь указал значение именно от 1 до 7, так как наша игра имеет всего семь уровней сложности. Если пользователь введёт значение от 1 до 7, запустится игра, ей будет дан старт. Если же он введёт что-то другое, игра не запустится, потому что пользователь указал ошибочное значение, не то значение, которое мы ему предлагали ввести.

Значение переменной lvl передается в круглые скобки при создании объекта:

```
Window w = new Window(lvl);
```

Поэтому необходимо перейти в класс Window, для этого сверху необходимо выбрать другую закладку и перейти в конструктор класса Window. В круглых скобках конструктора необходимо добавить переменную, получится:

```
...
public Window(int lvl) {
    ...

```

В строку, которая находится на несколько строчек ниже, в круглые скобки необходимо передать эту переменную:

```
gameField = new Field(lvl);
```

Таким образом, мы принимаем значение сложности, переданное при создании объекта в классе Game, и передаем это значение в объект типа Field, который создается на основании класса Field. Поэтому нам необходимо перейти в класс Field и некоторые доработки внести в него.

Первое: к переменным класса Field добавить еще одну переменную, которая будет отвечать за выбранную сложность игры, список переменных будет выглядеть так:

```
private Image hat;
private Image bg;
public int x = 400;
private int lvl;
```

Второе: в конструктор класса Field, также как и в предыдущем классе, добавляем переменную:

```
...
public Field(int lvl) {
    ...
```

В этом случае происходит прием значения при создании объекта. И третье, необходимо в начало конструктора добавить строку:

```
this.lvl = lvl;
```

На этом примере можно увидеть, как передать значение через круглые скобки в конструктор класса и там его использовать. В этой цепочке мы передали значение сложности сначала в класс Window, а потом в класс Field, но передали не напрямую, а через класс Window.

Теперь можно запустить нашу программу на выполнение. Появилось диалоговое окно. В самом верху этого окна заголовок: Сложность игры. Это третий по порядку параметр, указанный в описании. Заголовок можно сделать любым. Далее выводится сообщение пользователю: Введите сложность игры от 1 до 7. Это как раз второй параметр, указанный в описании. Первый параметр был null, (т. е. уровень сложности не указывался).

Пользователь вводит, например, цифру 1 и нажимает ОК. Появилось окно с игровым полем, потому что пользователь ввёл правильное значение: от единицы до семи.

Теперь можно еще раз запустить программу снова и ввести, например, цифру 8. В данном случае ничего не произошло, игра не запустилась - пользователь ввёл неверное значение. Цифра 8 является ошибочной при вводе, и наша конструкция if, осуществляющая проверку, не выполнит условие, которое указано внутри круглых скобок, так как 8 не лежит в диапазоне от единицы до семи. В условии указано, что сложность должна быть больше или равна единице и, одновременно (два значка &&), сложность должна быть меньше или равна семи. Если это условие не выполняется, игра не запускается. Таким образом, мы проконтролировали правильность ввода введённого значения.
Теперь, после внесения корректировок, переходим в класс Field. Основная часть программы, над которой мы будем работать на сегодняшнем занятии, находится в классе Field. Добавим программный код для дальнейшей реализации игры.

В самом верху, где объявляются переменные класса, объявим массив:

```
public class Field extends JPanel {
	private Image hat;
	private Image bg;
	public int x = 400;
	private int lvl;
	private Gift[] giftArray;
```

На прошлом занятии мы уже рассматривали, что такое массив и как с ним работают. Объявление массива отличается от объявления обычной переменной тем, что после типа переменной указываются пустые квадратные скобки []. Поле закрытое - private. Массив в данном случае типа Gift, a Gift - это класс, отвечающий за подарки. Таким образом, массив под названием giftArray - это массив подарков, с которыми мы будем работать. Семь подарков должны будут появляться в верхней части экрана. Мы их поместим в массив и далее, через имя массива, можно будет к ним обращаться при помощи квадратных скобок.

Перейдём в конструктор, в ту его часть, где мы уже загружали два изображения из корня диска C: (hat u bg), под этими двумя загрузками напишем следующую конструкцию:

```
giftArray = new Gift[7];
for (int i = 0; i < 7; i++) {
    try {
        giftArray[i] = new Gift(ImageIO.read(new File("c:\\g" + i + ".png")));
    } catch(IOException ex) {}
}
```

giftArray - название массива, объявленного выше, массива типа Gift. Таким образом, создаётся массив. В самой первой строчке мы создали уже реальный массив и в квадратных скобках указали, что массив содержит 7 элементов. Теперь этот массив существует. При объявлении переменной ячеек массива еще не существовало, была только переменная, отвечающая за массив. Если представить, что массив - своего рода секция, содержащая шкафчики, то этой строкой мы создали секцию из 7 шкафчиков. Каждый шкафчик имеет свой номер. Номера элементов массива начинаются всегда с нуля. Если их семь, то номера элементов массива это 0, 1, 2, 3, 4, 5 и 6. Каждый такой шкафчик, т. е., каждый элемент массива, каждая ячейка массива содержит подарок.

В цикле for мы создали счётчик цикла целого типа int, назвали его і и указали его начальное значение 0. Записали условие пока і меньше 7.

Третья часть настройки цикла for - это i++. Значит, счётчик чикла будет увеличиваться на единицу, начиная с нуля до тех пор, пока он меньше семи. Таким образом, счётчик будет принимать значения 0, 1, 2, 3, 4, 5 и 6. Открывающая и закрывающая фигурные скобки содержат тело цикла for. Всё, что находится между ними, будет выполняться в цикле многократно. В нашем случае цикл отработает семь раз, начиная с і=0. В фигурных скобках
цикла помещена конструкция try-catch. Точно такая же конструкция try-catch использовалась и при загрузке изображений фона и шапки. В левой части строки giftArray[i] = new Gift(); идёт обращение к массиву giftArray, внутри квадратных скобок указано і, а і - это счётчик цикла, принимающий значения 0, 1, 2, 3, 4, 5 и 6. Мы будем пробегать по всем элементам массива (по всем шкафчикам), а номера у них идут как раз 0, 1, 2, 3, 4, 5 и 6, начиная с нуля. Мы можем к каждому из них обратиться. Конструкция, находящаяся в правой части строки giftArray[i] = new Gift(), создаёт объект на основании класса Gift, класса, реализованного на прошлом занятии.

На его основании теперь мы создаём объекты. Давайте сейчас откроем класс Field. Перейдём к его конструктору и вспомним, что внутри круглых скобочек конструктора мы указывали переменную с названием img типа Image, a Image - это картинка. Мы это делали для того, чтобы при создании объекта можно было указать конкретную картинку, которая связана с этим объектом (подарком).

Вернёмся к классу Field. Внутри круглых скобок в правой части строки, находящейся в блоке for идёт обращёние к изображению подарка: (new File("c:\\g"+i + ".png")). і является счётчиком цикла. Так как счётчик будет меняться, при каждом шаге цикла осуществится обращение к конкретному файлу-картинке с конкретным номером. На первом шаге цикла і=0, и в скобках пропишется следующее: (new File("C:\\g0.png")). Вспомним, g0.png - имя первого файла, хранящегося на диске С:. Файлы изображений подарков g0, g1, g2, g3, g4, g5, gб названы так именно для того, чтобы их можно было загрузить в цикле по порядку, автоматически. Так как счётчик цикла постоянно принимает разные значения, мы, таким образом, переберём все семь файлов в цикле, потому что их наименования идут чётко по порядку.

Остаётся добавить, что перед new File стоит оператор обращения к файлу: ImageIO.read, и new File помещён внутрь круглых скобок метода read. Такую же операцию мы выполняли для двух предыдущих картинок bg и hat. Отличие в том, что сейчас мы загружаем целый набор картинок, в данном случаe, семь штук, загружаем их в массив и одновременно создаeм объекты типа Gift. Таким образом, каждая картинка из корня диска C: будет загружена в свой объект, в свой подарок. После выполнения этой конструкции вся необходимая нам графика будет загружена, и с ней можно будет работать. Далее, нужно создать ещё один таймер, работающий со своим временным интервалом. Таймер должен делать следующее: проверять игровое поле и оценивать, сколько на нем находится подарков. Если количество подарков меньше номера сложности, в самом верху будет появляться дополнительный подарок. Например, если пользователь выбрал уровень сложности 3, через определённый интервал времени будет происходить проверка, сколько сейчас подарков на игровом поле. Если, допустим, два, то будет вводиться ещё один дополнительный. Если же три, то ничего происходить не будет. Итак, задача этого таймера: обновлять активные подарки на игровом поле.

Откроем на время класс Gift. В нем была создана переменная типа Boolean, логического типа, под названием асt. Она отвечает за активность подарка на игровом поле. Переменная асt имеет два значения: либо истина, либо ложь. Если ложь, подарок не отображается на игровом поле. Если истина, он активен, т. е., отображается. Вернёмся в класс Field.

Для того чтобы не писать код с нуля, скопируем блок, в котором определяется таймер, уже присутствующий в этом классе и вставим его выше. Несколько изменим этот код и получится следующее:

```
Timer timerUpdate = new Timer(3000, new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        updateStart();
    }
    });
    timerUpdate.start();

Timer t = new Timer(50, new ActionListener() {
    public void actionPerformed(ActionEvent e) {
    repaint();
    }
});
t.start();
```

Первое что поменялось - это его наименование, мы назвали его timerUpdate. Временной интервал вместо пятидесяти укажем три тысячи. Три тысячи - это три секунды. Таким образом, просмотр количества подарков на игровом поле будет происходить каждые три секунды. Вместо метода repaint() мы поместили метод updateStart();. Этот метод подчёркивается красным цветом потому, что он ещё не создан. Создадим и пропишем его чуть позднее. Таймер каждые три секунды будет вызывать метод updateStart(); Именно этот метод и будет проверять количество подарков на игровом поле и, при необходимости, выводить туда новые подарки. Наконец, в самой последней строчке скопированного блока поменяем название таймера на timerUpdate. Команда start() запускает таймер на начало его работы. Так как наш новый таймер называется timerUpdate, то в команде start(), перед её вызовом, мы указали его имя.

Осталось добавить программный код ещё в двух местах. Первое, где нужно сделать дополнение - метод paintComponent. Метод paintComponent() отвечает за перерисовку игрового поля, то есть за перерисовку панели, которая находится внутри окна. Вспомним, что таймер под названием t каждые пятьдесят тысячных секунды, то есть двадцать раз в секунду, вызывает метод repaint(). Метод repaint() - это перерисовка. Во время вызова метода repaint() срабатывает метод paintComponent(). Можно считать, что метод repaint - это и есть вызов метода paintComponent(). Сейчас метод paintComponent() двадцать раз в секунду рисует фон и шапку, соответственно, в том месте, где она должна находиться на текущий момент, так как шапка перемещается при помощи стрелочек вправо и влево. Теперь добавились новые изображения - подарки, значит нужно дополнить код. После того, как отрисованы фон и шапка, нужно также постоянно отрисовывать подарки. Добавим после рисования фона и шапки код.

```
public void paintComponent(Graphics gr) {
    super.paintComponent(gr);
    gr.drawImage(bg, 0, 0, null);
    gr.drawImage(hat, x, 465, null);
    
    for (int i = 0; i < 7; i++) {
        giftArray[i].draw(gr);
    }
}
```

Создаем счётчик цикла for целого типа под названием і, приравниваем его к нулю, указываем условие і<7 и указываем, что счётчик будет меняться на единицу, то есть увеличиваться на один. Цикл for похож на тот, что мы использовали ранее. Его настроечная часть такая же и смысл такой же: он будет перебирать все элементы массива, все "шкафчики", в которых хранятся подарки. Каждый из них имеет свой номер. Можно представить, что это секция шкафчиков и на каждом из них написан номер 0, 1, 2, 3, 4, 5 и 6, и если открыть дверку шкафчика, можно найти там подарок. У каждого подарка свое изображение. После обращения к очередному элементу массива через оператор точка (.) мы вызываем метод draw(), который описан в классе Gift. Внутри круглых скобок метода draw() указано значение переменной gr, это переменная типа Graphics, через неё как раз и осуществляется рисование объектов. Что же здесь происходит? Цикл for пробегает по всем подаркам, т. е., по номерам от нуля до шести включительно. Получается ровно семь. В каждом элементе массива хранится подарок, созданный нами на основании класса Gift на прошлом занятии. Для каждого из них вызывается метод draw(), созданный на прошлом занятий внутри класса Gift. Метод draw() проверяет: если свойство асt равно true, истина, если подарок активен, он вызывает метод gr.drawImage. gr.drawImage() - это рисование изображения на панели, на игровом поле. Каждый подарок имеет своё изображение, т. е., каждый обьект, созданный на основании класса Gift, имеет своё изображение. Класс один, а объектов на его основании можно создать много. В данном случае, на основании одного класса было создано семь объектов и каждый объект помещён в массив. Таким образом, цикл for пробегает весь массив подарков, и проверяет: если подарок активен, если он должен присутствовать на игровом поле, он рисуется, если нет, соответственно, не рисуется. Теперь всё связанное с отрисовкой реализовано. Далее, ниже метода public void paintComponent(), создадим ещё один метод:

Сделаем его закрытым private, укажем void - значит, метод не возвращает никакого значения, укажем updateStart() - наименование метода:

```
private void updateStart() {

}
```

Вспомним, при создании нового таймера timerUpdate, мы указали внутри него метод updateStart(), метод, который мы сейчас создаём. Таймер через каждые три секунды вызывает метод updateStart(). Метод updateStart() анализирует, какая сложность выбрана пользователем, считает количество активных обьектов, у которых свойство асt равно true, (т. е. объектов-подарков, находящихся в этот момент на экране). Если сложность больше количества объектов, он выводит на игровую панель дополнительный подарок. Этот метод постоянно контролирует соответствие количества подарков на игровом поле уровню сложности игры. Если пользователь выбрал 1 уровень сложности - метод контролирует, чтобы был один подарок и т. д. Итак, в методе updateStart() введём следующий код:

```
private void updateStart() {
    int count = 0;
    
    for (int i = 0; i < 7; i++) {
        if (giftArray[i].act == false) {
            if (count < lvl) {
                giftArray[i].start();
                break;
            }
        } else count++;
    }
}
```

Создана переменная целого типа int, под названием count, ей присвоено значение 0. Эта переменная необходима для того, чтобы посчитать количество подарков на игровом поле. Переменная count отвечает за их подсчёт.

Далее следует цикл for. Настроечная часть цикла for такая же, как и ранее. Цикл for пробегает по всем элементам массива и проверяет активность каждого из элементов. Тело цикла for находится в фигурных скобках и содержит следующее: if (giftArray[i].act == false). act - это активность подарка. Если подарок активен, он отображён на игровом поле, значит свойство асt сейчас установлено в true (истина). Если свойство false (ложь), т. е., подарок неактивен, идёт переход в конструкцию else. Всё, что внутри фигурных скобок, которые ограничивают программный код, от if до else выполняется, если условие, указанное внутри круглых скобок if, выполняется.

Внутри записана еще одна конструкция if. В ней записано следующее: если count, количество подарков, находящихся на игровом поле, меньше, чем lvl (переменная lvl отвечает за сложность, выбранную пользователем), то происходит следующее: активизация подарка на игровом поле - его "старт": giftArray[i].start(); и прерывание цикла: break.

Команда break - прерывает цикл, в данном случае это наш цикл for. Метод start() описан внутри класса Gift. На время перейдем в класс Gift, найдём метод start() и посмотрим, что же внутри него находится. Метод start() делает следующее: он запускает этот таймер, координату у он устанавливает в ноль. Таким образом, подарок будет помещаться в самой верхней части. Координату х он выбирает случайным образом. На прошлом занятии мы рассматривали, как работает оператор Math.random(). Он позволяет получить случайное значение, в данном случае, от нуля до семисот. Это значит, что подарок появится в случайном месте в верхней части игрового поля. И в конце свойству асt устанавливается в значение frue - истина. Это значит, что подарок активен, он отображается на игровом поле, и, когда будет происходить перерисовка, мы увидим, как он падает вниз. Вернёмся в класс Field. Рассмотрим последнюю конструкцию, записанную в теле метода updateStart() после фигурной скобки первого оператора if, конструкцию иначе: else count++; Что происходит при выполнении этой строки? Переменная count увеличится на единицу. А переменная count как раз отвечает за подсчёт количества подарков, в данный момент активных на игровом поле. В начале значение этой переменной 0, но при переборе всех подарков (их семь), как только будет встречаться активный подарок, значение переменной count увеличится на единицу. Вот таким образом работает эта схема. Запустим нашу программу на исполнение. Выберем, например, сложность 3, нажмём ОК. На игровом поле будут появляться три подарка, которые падают вниз. Мы eщё не закончили писать программу игры, пока создана часть,отвечающая за появление подарков в случайном месте сверху на игровом поле, движение вниз до самой минимальной разрешимой для подарков границ, то есть до верхней границы шапки. На следующем занятии мы введем в программу такую проверку: в момент, когда подарок достигает самой нижней границы, а шапочки внизу нет (он пропущен), значит, игра будет окончена. Если же он успешно пойман, игра продолжается. Если подарок не пойман, будет выводиться табличка game over.