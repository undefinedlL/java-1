# Занятие 6. Работа с графическими изображениями.

### На этом занятии:
- мы научимся загружать в создаваемое нами гзафическое приложение графические файлы и выводитьь их на экран
- научимся создавать анимированное движение 
- научимся управлять движущимся графическим объектом с помощью клавиатуры

## Ход занятия 

Откроем Eclipse и создадим новый проект - lesson6.

Удалим заготовку программы, так как мы будем использовать начальную заготовку программы, сделанную нами на прошлом занятии. Откроем программу прошлого занятия с готовым исходным кодом, скопируем его и вставим его в наш новый проект.

\\ Main.java
``` 
    import java.awt.*;
    import javax.swing.*;
    public class Main {
        public static void main(String[] args) {
            Frame nf = new Frame();
        }
    }
    class Frame extends JFrame {
        public Frame() {
            Panel pn = new Panel();
            Container cont = getContentPane();
            cont.add(pn);
            setBounds(10, 10, 800, 600);
            setVisible(true); 
        }
    }
    class Panel extends JPanel {
        public void paintComponent(Graphics gr) {
            gr.setColor(Color.BLUE);
            for (int i = 0; i < 10; i++) {
                gr.fillRect(10*i, 10*i, 50*i, 50*i);
            }
        }
    }
```


Повторим основные моменты прошлого занятия.

Команда import осуществляет добавление библиотек для возможности их использования в нашей программе. Библиотека - это набор определенных функций, вызываемых в виде команд для выполнения тех или иных задач.
	
Основной класс программы - этот класс всегда называется так же, как и имя файла, содержащего программу. В данном случае - Main. Внутри этого класса находится метод, который создается при установке галочки для создания классов public static void main(String[] args). Метод main -  метод, который запускает программу. 

Frame f = new Frame(); - строка, которая создает объект окна на основании класса, который описан ниже (class Frame extends JFrame). Внутри этого класса описывается настройка, связанная с окном. Слово class говорит о том, что создан класс под названием Frame. Название класса может быть произвольным, как и название переменной. Оператор extends присваивает классу Frame наследование свойств и методов класса JFrame. Класс Frame содержит один метод, который производит инициализацию окна. setBounds  - устанавливает положение окна и его размеров. Первые две характеристики - отступы, остальные две отвечают за размеры окна. Panel является типом переменной под названием pn. В части new Panel(); мы создаем объект под названием pn. Эта панель будет вставлена в наше окно. На ней будет отображаться графика. Панель представляет из себя прямоугольную область, размещенную внутри окна. Далее идет строка Container cont = getContentPane(); позволяющая подключать к окну компоненты. Эта связка происходит через переменную cont. Название может быть любым, но желательно имя переменной задавать созвучным ее назначению. Строка cont.add(pn); прикрепляет панель к нашему окну - вкладывает ее к окну. Строка setVisible(true); позволяет сделать окно видимым.

В программе описан еще один класс - класс под название Panel, он наследуется от класса JPanel. Класс JPanel - класс панелей, которые можно размещать внутрь окна.

Метод public void paintComponent используется для возможности рисования на панели или отображения внешних графических файлов с диска.

Мы продолжаем работать с графикой и сейчас мы рассмотрим работу с изображениями, находящимися в графических файлах.

Для возможности использования изображений, хранящихся в файлах на вашем компьютере, при создании приложений, их следует в программу загрузить. (изображение вы можете взять свое или же можете взять из директории текущего занятия ./img)

Любое изображение можно поместить в прямоугольную область. Именно эта область определяет характеристики изображения. Представим, что прямоугольник внутри нашего окна - это панель, и зададим распольжение точки, относительно которой рассчитывается положение объекта. Чтобы задать положение этого изображения в нашем окне, нужно указать отступ по X и по Y (в количестве пикселей) - координаты верхнего левого угла изображения. После этого следует задать ширину и высоту изображения. Эти характеристики присутствуют у любого изображения. Выведем в окно изображение, помещенное на диск C. Для этого добавим в класс Panel новую переменную. Объявим ее в самом верху класса после открывающей фигурной скобки. Используем модификатор private, тогда переменная класса будет закрытой, то есть доступной только внутри класса. Далее мы указывааем ее тип: Image, то есть картинкой: private Image img;. 

Далее создадим новый метод под названием public Panel, а код внутри метода public void paintComponent удалим, класс Panel теперь выглядит так:


```

class Panel extends JPanel {
	
	private Image img;
	
	public Panel() {
		
	}
	
	public void paintComponent(Graphics gr) {
		
	}
}

```


В метод public Panel() добавим строки:

```
try 
{
    img = ImageIO.read(new File("c://m.gif"));
} 
catch(IOException exp) {}
```

В самом верху программы добавим: 

```
import java.io.*;
import javax.imageio.*;
```

А внутри метода public void paintComponent(Graphics gr) добавим одну строку:

```
gr.drawImage(img, 10, 10, null);
```

После этого у нас получится следующая программа: 

```

import java.awt.*;
import java.io.*;
import javax.imageio.*;
import javax.swing.*;


public class Main {
	public static void main(String[] args) {
		Frame nf = new Frame();
	}
}

class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container c = getContentPane();
		c.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true); 
	}
}

class Panel extends JPanel {
	
	private Image img;
	
	public Panel() {
		try 
		{
			img = ImageIO.read(new File("c://m.gif"));
		} 
		catch(IOException exp) {}
	}
	
	public void paintComponent(Graphics gr) {
		gr.drawImage(img, 10, 10, null);
	}
}

```

В верхних 2-х строчках мы подключили две библиотеки, которые нужны для загрузки графических файлов. При помощи команды img = ImageIO.read(new File("c://m.gif")); мы загрузили в нашу программу файл под названием m.gif, который находится на диске C.

Часть строки ImageIO.read выполняет функцию чтения изображения. В первых круглый скобках создается объект типа File: new File, во внутреннних скобках указывается конкретный путь к месту нахождения изображения на диске C. То есть часть строки new File создает объект типа File и путь к этому файлу "c:\\m.gif". Путь указывается в двойных кавычках, как строка. Обратите внимание, что при описании пути необходимо указывать именно две косые черты. Одна косая черта является специальным символом. Чтобы дать понять компилятору, что это не специальный символ, а косая черта - их нужно писать две. Изображение загружается и связывается в переменную img, специально для этого созданной. Ее тип Image - картинка. 

Метод gr.drawImage(img, 10, 10, null); - выводит этот файл на нашу панель окна. drawImage - отвечает за выведение изображения на экран. Первый параметр -  изображение img, которое мы выводим. Вторые два - координаты X и Y. Значения 10 и 10 говорят о том, что изображение выводится почти из верхнего левого угла окна. Последний параметр не указан. Неуказанные параметры отображаются, как null - специальное служебное слово, говорящее о том, что параметр пустой.

Мы обратились к переменной с именем gr типа Graphics, которая отвечает за выведение графики на нашу панель. В дальнейшем, для произведения графических манипуляций мы будем обращаться к этой переменной.

Попробуем запустить нашу программу, и если она написана без ошибок, то мы увидим изображение, выведенное на экран. Координата 10, 10 находится в левом верхнем углу окна, именно из этой точки начинается прямоугольник, содержащий изображение. Соответственно, если эту координату поменять и поставить, например, 200, 200, - после выполнения программы можно увидеть, что изображение сместилось, так как точка его начала координат переместилась. Таким образом, можно менять положение изображения на рабочей области и выводить его в любой точке. Можно использовать любые картинки, изображения, подготовленные в каком-либо графическом редакторе. К примеру, можно взять что-то готовое, и использовать в программах, например, для оформления какой-то игры, чтобы наполнить ее дизайном и графическими объектами.

Теперь перейдем к понятию анимации. Анимация движений - это перемещение графического объекта по определенной области или его изменение, в данной случае, области панели, вложенной в окно.

Можно заложить траекторию движения изображения, например, прямую линию. Вдоль этой линии будет двигаться заданный объект. Можно взять более сложную траекторию движения, например, окружность. Тогда объект будет двигаться по окружности. Для создания нашей анимации нам нужно выполнить несколько действий:

1) перемещать изображение на небольшое расстояние (пошагово). Если необходимо перемещать изображение по диагонали, его координату по X и Y нужно изменять на один пиксель, тогда оно переместиться совсем немного.
2) после перемещения очистить его предыдущее положение (еще лучше это сделать до перемещения: перед тем, как поместить изображение в новую точку).

Тогда изображение будет двигаться. В зависимости от того, на сколько пикселей за шаг перемещается изображение, меняется плавность его движения. Есть еще одно необходимое условие - определенная временная задержка. Если ее не предусмотреть, компьютер выполнит перемещение объекта мгновенно, и объект промелькнет на экране, но заметить это будет практически невозможно. Поэтому необходимо задавать скорость движения объекта, не зависящую от скорости работы компьютера. Перед переходом на новый кадр, на новое положение изображения, делается временная задержка, допустим, какая-то доля секунды. Для этого есть специальный инструмент - таймер. 

Таймер позволяет выполнять задержку с точностью до одной тысячной секунды. Попробуем создать этот инструмент и начнем с ним работать. Добавим еще несколько полей в наш класс и назовем их x и y.
Зададим им начальное значение 0 и 0.

```

class Panel extends JPanel {
	private int x=0, y=0;

```

Это переменные x и y целого типа, они так же закрытые - private, то есть доступны только внутри класса. Они будут отвечать за положение нашего изображения на экране, то есть за положение верхней левой точки. Меняя значение параметров x и y, можно перемещать объект. Чтобы перемещение не оставляло следа и получилась реальная анимация, перед тем как отобразить изображение в новом месте, нужно очистить область от прежнего изображения. Для этой цели применяется метод clearRect - очищение прямоугольной области. Добавим над строкой вывода изображения строчку:

```

gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);

```

и в самой строке вывода изображения поменяем значения координат 10, 10 на x и y. Получится следующий фрагмент кода:

```

public void paintComponent(Graphics gr) {
	gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
	gr.drawImage(img, x, y, null);
}

```

Обращение к методам очищения и вывода идет через переменную gr, типа Graphics. Внутри круглых скобок метода gr.clearRect, указываются: первые два парамметра - координаты верхней левой точки прямоугольной области очищения. Если перемещать объект на один пиксель, достаточно делать очищение в радиусе +- один пиксель (x-1, y-1). Получается точка, удаленная на один пиксель по x и по y, соответственно, вверх и влево. Вторые два параметра: ширина и высота прямоугольной области очищения. Обратимся к изображению img и вызовем команду getWindth(null), позволяющую вычислить ширину изображения выведенного на экран. null говорит о том, что параметр не указывается, он остается пустым. Снова обращаемся к изображению img и вызываем метод getHeight(null), она задает высоту нашего графического объекта. Именно эти два параметра указывают ширину и высоту области, которая будет очищена. К высоте и ширине прибавляем по одному пикселю, чтобы охватитьь чуть больший фрагмент, потому что объект каждый раз перемещается на один пиксель. Перед тем, как выводить изображение в новом положении панели, программа будет производить очищение области, большей на единицу со всех сторон. Так осуществляется анимация.

Теперь добавим несколько строк для работы с таймером. Их необходимо поместить в метод public Panel().

```

public Panel() {
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				x++;
				repaint();
			}
		});
		nt.start();
		
		....

```

Таким образом, мы создали таймер, он будет работать с нашим приложением. Первый параметр, который необходимо указать - его временную задержку. Мы указали 50, это значит, что задержка будет 50 тысячных секунды. При срабатывании таймера будет происходить отрисовка заданной области, то есть панели. Метод repaint(); вызывает перерисовку, вызывает на исполнение метод public void paintComponent(Graphics gr), он заново перерисовывает заданную облать. А в нем у нас выполняются две команды - очищение области с положением изображения на предыдущем шаге и вывод изображения в новом месте. Перерисовка будет выполняться 20 раз в секунду - именно этому соответствует задержка 50 тысячных секунды.

Сверху подключим еще одну библиотеку:

```

import java.awt.event.*;

```

Запустим программу и увидим перемещение, анимацию нашего изображения. Полный код программы должен выглядеть так:

```

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.imageio.*;
import javax.swing.*;


public class Main {
	public static void main(String[] args) {
		Frame nf = new Frame();
	}
}

class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container c = getContentPane();
		c.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true); 
	}
}

class Panel extends JPanel {
	private int x=0, y=0;
	private Image img;
	
	public Panel() {
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				x++;
				repaint();
			}
		});
		nt.start();
		
		try 
		{
			img = ImageIO.read(new File("c://m.gif"));
		} 
		catch(IOException exp) {}
	}
	
	public void paintComponent(Graphics gr) {
		gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
		gr.drawImage(img, x, y, null);
	}
}


```


Добавим на одну строку ниже от объявления переменных x и y еще одну, переменную целого типа и назовем ее direction, присвоим ей начальное значение равное 2, переменная будет закрытой:

```

private int direction = 2;

```

Переменная direction отвечает за направление движения графического объекта. Договоримся, что у нас будет 4 возможных направления: вверх, вниз, вправо, влево. Каждое направление будет обозначаться цифрой 0, 1, 2, 3. Тогда 2 отвечает за движение вправо. Если direction = 2, объект перемещается в правом направлении. Теперь вместо строки x++;  - там, где мы создавали таймер, поместим строки:

```

if (direction == 0) x--;
if (direction == 1) y--;
if (direction == 2) x++;
if (direction == 3) y++;

```

Операция x--; означает, что значение x будет уменьшаться на единицу. Если x был равен 100, после выполнения этой операции он станет равным 99. Если direction==0, координата x уменьшится на единицу. Если direction==1, то координата y уменьшится на единицу. Если direction==2, координата x увеличится на единицу. И, наконец, если direction==3, координата y увеличится на единицу. 

Мы прописали следующее условие: если направление равно 0, тогда координата X будет уменьшаться на единицу, и объект будет перемещаться влево. Если направление равно 1, Y уменьшается и объект перемещается вверх. Если направление равно 2, координата X увеличивается на единицу, и объект перемещается вправо. И, наконец, если направление равно 3, тогда координата Y увеличивается, и объект будет перемещаться вниз. Таким образом, можно работать с четырьмя направлениями движения.

Часть программного кода, описывающего таймер теперь будет выглядеть так:
```

Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (direction == 0) x--;
				if (direction == 1) y--;
				if (direction == 2) x++;
				if (direction == 3) y++;
				repaint();
			}
		});
		nt.start();

```

Последняя строка этого кода nt.start(); запускает таймер. После ее выполнения таймер начинает работать. Давайте чуть-чуть поменяем скорость движения объект, изменим задержку с 50 на 100 и запустим программу, мы увидим, что объект стал двигаться медленнее. А теперь поменяем ее на 25, мы увидим, что объек стал двигаться быстрее.

Для создания любой компьютерной игры нужно обеспечить необходимое условие: возможность управления ею. Для этих целей используются, например, клавиатура и мышь. В нашем случае можно использовать клавиатуру для управления движением  нашего графического объекта, каждая стрелочка будет задавать направление движения вверх, вниз, вправо и влево. При нажатии клавиши происходит определенное событие. Событие, организованное нажатием клавиши на клавиатуре. Это событие передается в программу, где программист может ее обработать. Каждая клавиша имеет свой уникальный код, то есть номер. Допустим, стрелочка вправо имеет код 39, соответственно, каждая другая клавиша имеет другой код. По номеру нажатой клавиши, по ее коду программа может четко определить, какую клавишу нажал пользователь и среагировать именно на это нажатие. Возьмем переменную под названием direction, принимающую четыре значения. Можно сделать так, что при нажатии, например, стрелочки вправо, значение переменной direction будет меняться на 2, при нажатии на клавишу вниз, оно будет меняться на 3, при нажатии клавиши вверх - на 1, и при нажатии клавиши влево - на 0. Если организовать такую логику, объект будет перемещаться относительно нажатых клавиш. Добавим программный код, позволяющий обработать нажатие клавиш. 

```

class Panel extends JPanel {
	private int x = 0, y = 0;
	private Image img;
	private int direction = 2; 
	
	private class Key implements KeyListener {
		public void keyPressed(KeyEvent e) {
			int key_ = e.getKeyCode();
			
			if (key_ == 37) direction = 0;
			if (key_ == 38) direction = 1;
			if (key_ == 39) direction = 2;
			if (key_ == 40) direction = 3;
		}
		public void keyReleased(KeyEvent e) {}
		public void keyTyped(KeyEvent e) {}
	}
	...

```

Как работает эта конструкция, мы будем рассматривать позднее (не забывайте, что регистр букв имеет значение, заглавная и маленькая буквы считаются разными).

В строке int key_ = e.getKayCode(); объявлена переменная целого типа под названием key_. Она содержит код нажатой клавиши, номер, определяемый при помощи метода e.getKeyCode();. Далее, анализируем, какую клавишу нажимает пользователь. Если код клавиши равен 37, направление движения устанавливаем 0. Если код клавиши равен 38, указываем направление 1. Если код клавиши 39, то направление 2.И если код клавиши 40, то направление - 3. Коды клавиш можно найти в любой тематической литературе, узнать в интернете. А можно сделать немного проще: написать строку вывода на экран значений переменной key_: после строки int key_ = e.getKeyCode(); вставить строку:

```
System.out.println(key_);
```

тогда при нажатии клавиши - в консольном окне будет выводиться код нажатой клавиши. Для отработки нажатий клавиш - нам осталось выполнить последнее, вставить перед объявлением таймера строки:

```

addKeyListener(new Key());
setFocusable(true);

```

эти строки подключают обработчик событий клавиатуры к нашей панели окна. Теперь можно запустить программу, при нажатии стрелочек на клавиатуре - наш графический объект будет перемещаться в нужных направлениях. Полный код нашей программы должен выглядеть вот так:

```

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import javax.imageio.*;

public class Main {
	public static void main(String[] args) {
		Frame f = new Frame();
	}
}
class Frame extends JFrame {
	public Frame() {
		Panel pn = new Panel();
		Container cont = getContentPane();
		cont.add(pn);
		setBounds(10, 10, 800, 600);
		setVisible(true);
	}
}
class Panel extends JPanel {
	private int x = 0, y = 0;
	private Image img;
	private int direction = 2; 
	
	private class Key implements KeyListener {
		public void keyPressed(KeyEvent e) {
			int key_ = e.getKeyCode();
			
			if (key_ == 37) direction = 0;
			if (key_ == 38) direction = 1;
			if (key_ == 39) direction = 2;
			if (key_ == 40) direction = 3;
		}
		public void keyReleased(KeyEvent e) {}
		public void keyTyped(KeyEvent e) {}
	}
	
	public Panel() {
		
		addKeyListener(new Key());
		setFocusable(true);
		
		Timer nt = new Timer(50, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (direction == 0) x--;
				if (direction == 1) y--;
				if (direction == 2) x++;
				if (direction == 3) y++;
				repaint();
			}
		});
		nt.start();
		try {
			img = ImageIO.read(new File("c:\\m.gif"));
		} catch (IOException exp) {}
	}
	public void paintComponent(Graphics gr) {
		gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
		gr.drawImage(img, x, y, null);
	}
} 

```

Мы реализовали возможность управления объектом с помощью клавиатуры. Давайте обсудим полученный результат.

При нажатии определенной клавиши мы меняли значение переменной direction, соответственно: 0, 1, 2, 3. В таймере, в зависимости от переменной direction, по-разному менялись переменные x и y. Объект двигался в разных направлениях, а отрисовка движений происходила всегда здесь:

```

public void paintComponent(Graphics gr) {
	gr.clearRect(x-1, y-1, img.getWidth(null)+1, img.getHeight(null)+1);
	gr.drawImage(img, x, y, null);
}

```

Первая строчка очищала предыдущую область, где располагался объект, затем помещался в новом месте. Вызов методотрисовки происходил каждый раз при срабатывании таймера, это выполняла строка:

```
repaint();
```

Таким образом, получилась управляемая анимация движения.

Теперь у нас еще больше возможностей для создания компьютерных игр. Во-первых, мы умеем управлять объектами при помощи клавиатуры. Можем вывести любой объект на экран, перемещать этот объект по экрану, то есть создавать анимацию.
В данном случае был создан один объект, а можно создавать множество объектов, каждый из которых будет двигаться по своей траектории движения. Объекты могут быть разные, соответственно, поведение на игровом поле у них тоже может быть разным. Таким образом, мы уже можем создать небольшую компьютерную игру, оформить ее, и организовать ее управление.